#pragma config(Hubs, S1, HTMotor, HTMotor, none, none)
#pragma config(Sensor, S1, , sensorI2CMuxController)
#pragma config(Sensor, S2, touch, sensorTouch)
#pragma config(Sensor, S3, light, sensorLightActive)
#pragma config(Sensor, S4, sonar, sensorSONAR)
#pragma config(Motor, mtr_S1_C1_1, motorD, tmotorTetrix, openLoop, encoder)
#pragma config(Motor, mtr_S1_C1_2, motorE, tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor, mtr_S1_C2_1, , tmotorTetrix, openLoop)
#pragma config(Motor, mtr_S1_C2_2, , tmotorTetrix, openLoop)
#include "JoystickDriver.c"
task main()
{
   if(SensorValue(sensorInfrared) < 5) //this is to account for the fact that the IR beacon could be on either of the two sides of the rack
   	{
   	while(SensorValue(sensorInfrared) != 2)
   		{
   		motor[motorD] = 100;
   		motor[motorE] = 100;
   		}
   	}
   else
   	{
   	while(SensorValue(sensorInfrared) != 8)
   		{
   		motor[motorD] = 100;
   		motor[motorE] = 100;
   		}
   	}
   
   motor[motorD] = 100;
   motor[motorE] = 100;
   wait1Msec(20);
   
   if(SensorValue(sensorInfrared) < 5)
   	{
   	while(SensorValue(sensorInfrared) != 5) 
   		{
   		motor[motorD] = 50; //make sure this turns the robot to the left
   		motor[motorE] = -50;
   		}
   	while(SensorValue(sensorInfrared) != 2)
   		{
   		motor[motorD] = 100;
   		motor[motorE] = 100;
   		}
   	}
   else
   	{
   	while(SensorValue(sensorInfrared) != 5)
   		{
   		motor[motorE] = 50; //adjust so that it turns right
   		motor[motorD] = -50;
   		}
   		
   	while(SensorValue(sensorInfrared) != 8)
   		{
   		motor[motorD] = 100;
   		motor[motorE] = 100;
   		}
   	}
   	
   if(SensorValue(sensorInfrared) < 5)
   	{
   	while(SensorValue(sensorInfrared) != 5)
   		{
   		motor[motorD] = 50;
   		motor[motorE] = -50;
   		}
   	}
   else
   	{
   	while(SensorValue(sensorInfrared) != 5)
   		{
   		motor[motorE] = 50;
   		motor[motorD] = -50;
   		}
   	}
   	
   motor[motorD] = -75;
   motor[motorE] = -75;
   wait1Msec(1000);//change to make sure it doesn't hit the wall behind it
   
   nMotorEncoder[motorF] = 0;
   nMotorEncoderTarget[motorF] = n; //set this to be whatever it needs to be so as to make the arm move down into position
   motor[motorF] = 25;
   while(nMotorRunState[motorF] != runStateIdle) {}
   
   while(SensorValue(sensorSonar) > 10) //we'll need to play around with this value a bit
   	{
   	motor[motorD] = 50;
   	motor[motorE] = 50;
   	}
   	
   motor[motorA] = 50;
   motor[motorB] = 50;//These should be replaced with the motors that govern the conveyor thing and the signs should be adjusted accordingly so as to make them put the cube into the container
   wait1Msec(3000);
   
   motor[motorD] = -75;
   motor[motorE] = -75;
   wait1Msec(1000);//change to make sure it doesn't hit the wall behind it
   
   nMotorEncoder[motorD] = 0;
   nMotorEncoderTarget[motorD] = 90;
   motor[motorD] = 75;
   motor[motorE] = -75;
   while(nMotorRunState[motorD] = runStateIdle) {}
   motor[motorE] = 0;
   
   while(SensorValue(sensorSonar) > 5)
      {
      motor[motorE] = 100;
      motor[motorD] = 100;
      }
   
   nMotorEncoder[motorE] = 0;
   nMotorEncoderTarget[motorE] = 90;  
   motor[motorD] = -75;
   motor[motorE] = 75;
   while(nMotorRunState[motorE] = runStateIdle) {}
   motor[motorD] = 0;
   
   motor[motorD] = 100;
   motor[motorE] = 100;
   wait1Msec(2000); //adjust to give it enough time to get to the center of the ramp
   
   nMotorEncoder[motorE] = 0;
   nMotorEncoderTarget[motorE] = 90;
   motor[motorD] = -75;
   motor[motorE] = 75;
   while(nMotorRunState[motorE] = runStateIdle) {}
   motor[motorD] = 0;//all of these blocks need to be adjusted so that it turnes 90 degrees either to the right or to the lef
   
   while(SensorValue(sensorSonar) > 226)
      {
      motor[motorD] = 100;
      motor[motorE] = 100;
      }
      
   motor[motorD] = 0;
   motor[motorE] = 0;
   
   
   
